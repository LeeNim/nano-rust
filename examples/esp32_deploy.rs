//! ESP32 Deployment Example — NANO-RUST-AI Firmware Template
//!
//! This is a complete example of how to use a model exported from Python
//! in a `no_std` ESP32 Rust firmware.
//!
//! # Prerequisites
//! 1. Export model from Python:
//!    ```
//!    python examples/export_for_esp32.py
//!    ```
//!    This creates `src/model.rs` with static weight arrays and a builder function.
//!
//! 2. Set up ESP32 Rust toolchain:
//!    ```
//!    cargo install espup
//!    espup install
//!    cargo install cargo-espflash
//!    ```
//!
//! 3. Add nano-rust-core to Cargo.toml:
//!    ```toml
//!    [dependencies]
//!    nano-rust-core = { path = "../core", default-features = false }
//!    esp-hal = { version = "0.16", features = ["esp32"] }
//!    ```
//!
//! # Memory Budget
//!
//! | Component          | Flash    | RAM      |
//! |--------------------|----------|----------|
//! | Frozen weights     | ~60KB    | 0 bytes  |
//! | Arena buffer       | 0 bytes  | 16KB     |
//! | Code + stack       | ~20KB    | ~4KB     |
//! | **Total**          | **~80KB**| **~20KB**|
//! | **ESP32 Available**| **4MB**  | **520KB**|
//!
//! # Workflow
//!
//! ```
//! Sensor Data → Quantize to i8 → NANO Inference → Predicted Class → Action
//! ```

#![no_std]
#![no_main]

// ============================================================================
// Import the exported model
// This file is auto-generated by: python examples/export_for_esp32.py
// It contains:
//   - static LAYER_0_W: &[i8] = &[...];   (weights in Flash)
//   - static LAYER_0_B: &[i8] = &[...];   (bias in Flash)
//   - pub fn build_sensor_model() -> SequentialModel<'static>
// ============================================================================
include!("model.rs");

use nano_rust_core::Arena;

// ============================================================================
// Configuration — adjust these for your application
// ============================================================================

/// Input features (must match the model's input_shape).
/// Examples:
///   - MNIST:    784 (28×28 pixels)
///   - Sensor:   6 (accel_x/y/z + gyro_x/y/z)
///   - MFCC:     416 (32 frames × 13 coefficients)
///   - BoW text: 100 (vocabulary size)
const INPUT_SIZE: usize = 6;

/// Arena buffer size in bytes.
/// Must be >= 2 × max(layer_output_size).
/// Use model.estimate_arena_size() in Python to compute this.
const ARENA_SIZE: usize = 4096;

/// Number of output classes.
const NUM_CLASSES: usize = 4;

/// Input quantization scale.
/// Computed during calibration: max_abs(training_data) / 127
const INPUT_SCALE: f32 = 0.0157;

// ============================================================================
// Static arena buffer — allocated at compile time, lives in RAM
// ============================================================================
static mut ARENA_BUF: [u8; ARENA_SIZE] = [0u8; ARENA_SIZE];

// ============================================================================
// Entry point
// ============================================================================
#[entry]
fn main() -> ! {
    // Initialize ESP32 peripherals
    // let peripherals = esp_hal::init(esp_hal::Config::default());
    // let mut i2c = I2c::new(peripherals.I2C0, ...);  // sensor bus
    // let mut uart = Uart::new(peripherals.UART0, ...); // debug output

    loop {
        // ================================================================
        // STEP 1: Read sensor data (float32 from hardware)
        // ================================================================
        let sensor_data: [f32; INPUT_SIZE] = read_sensors();
        // Example: [0.5, -0.3, 1.2, 0.1, -0.8, 0.4]
        //          [accel_x, accel_y, accel_z, gyro_x, gyro_y, gyro_z]

        // ================================================================
        // STEP 2: Quantize input to i8
        // ================================================================
        // Formula: i8_value = clamp(round(float_value / INPUT_SCALE), -128, 127)
        let mut input_i8 = [0i8; INPUT_SIZE];
        for i in 0..INPUT_SIZE {
            let scaled = (sensor_data[i] / INPUT_SCALE) as i32;
            input_i8[i] = scaled.clamp(-128, 127) as i8;
        }
        // Result: [32, -19, 76, 6, -51, 25]

        // ================================================================
        // STEP 3: Create arena and model
        // ================================================================
        // SAFETY: Single-threaded, no interrupts accessing ARENA_BUF
        let arena_buf = unsafe { &mut ARENA_BUF };
        let mut arena = Arena::new(arena_buf);

        // Build model from exported weights (all in Flash)
        let model = build_sensor_model(); // from include!("model.rs")

        // ================================================================
        // STEP 4: Run inference
        // ================================================================
        let input_shape = [INPUT_SIZE];
        match model.forward(&input_i8, &input_shape, &mut arena) {
            Ok((output, _shape)) => {
                // output: &[i8] with NUM_CLASSES values
                // e.g., [15, -40, 87, 3] → class 2 has highest activation

                // Get predicted class (argmax)
                let predicted_class = output
                    .iter()
                    .enumerate()
                    .max_by_key(|(_, v)| **v)
                    .map(|(i, _)| i)
                    .unwrap_or(0);

                // ========================================================
                // STEP 5: Take action based on prediction
                // ========================================================
                match predicted_class {
                    0 => { /* Normal operation */ }
                    1 => { /* Warning: vibration anomaly */ }
                    2 => { /* Alert: temperature spike */ }
                    3 => { /* Emergency: shutdown */ }
                    _ => { /* Unknown class */ }
                }

                // Debug output (if UART available)
                // uart_println!("Class: {}, raw: {:?}", predicted_class, output);
            }
            Err(_e) => {
                // Arena too small or dimension mismatch
                // uart_println!("Inference error: {:?}", e);
            }
        }

        // ================================================================
        // Wait before next inference cycle
        // ================================================================
        // delay.delay_ms(100u32);  // 10 Hz inference rate
    }
}

// ============================================================================
// Placeholder sensor read function
// Replace with actual I2C/SPI sensor communication
// ============================================================================
fn read_sensors() -> [f32; INPUT_SIZE] {
    // Example: MPU6050 accelerometer + gyroscope
    // In real firmware:
    //   let mut buf = [0u8; 14];
    //   i2c.read(0x68, &mut buf).unwrap();
    //   let accel_x = i16::from_be_bytes([buf[0], buf[1]]) as f32 / 16384.0;
    //   ...
    [0.5, -0.3, 1.2, 0.1, -0.8, 0.4]
}
